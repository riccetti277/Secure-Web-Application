/// <reference types="node" />
import { MessageHeader } from '@aws-crypto/serialize';
import { GetCipher, AwsEsdkJsCipherGCM, NodeAlgorithmSuite } from '@aws-crypto/material-management-node';
interface AccumulatingFrame {
    contentLength: number;
    content: Buffer[];
    sequenceNumber: number;
}
interface EncryptFrame {
    content: Buffer[];
    bodyHeader: Buffer;
    headerSent?: boolean;
    cipher: AwsEsdkJsCipherGCM;
    isFinalFrame: boolean;
}
declare type ErrBack = (err?: Error) => void;
export declare function getFramedEncryptStream(getCipher: GetCipher, messageHeader: MessageHeader, dispose: () => void, { plaintextLength, suite, }: {
    plaintextLength?: number;
    suite: NodeAlgorithmSuite;
}): {
    _transform(chunk: Buffer, encoding: string, callback: ErrBack): void;
    _flush(callback: ErrBack): void;
    _destroy(): void;
    _read(size: number): void;
    _flushEncryptFrame(encryptingFrame: EncryptFrame): Promise<void>;
    readonly writable: boolean;
    readonly writableEnded: boolean;
    readonly writableFinished: boolean;
    readonly writableHighWaterMark: number;
    readonly writableLength: number;
    readonly writableObjectMode: boolean;
    readonly writableCorked: number;
    allowHalfOpen: boolean;
    _write(chunk: any, encoding: BufferEncoding, callback: (error?: Error | null | undefined) => void): void;
    _writev?(chunks: {
        chunk: any;
        encoding: BufferEncoding;
    }[], callback: (error?: Error | null | undefined) => void): void;
    _final(callback: (error?: Error | null | undefined) => void): void;
    write(chunk: any, encoding?: BufferEncoding | undefined, cb?: ((error: Error | null | undefined) => void) | undefined): boolean;
    write(chunk: any, cb?: ((error: Error | null | undefined) => void) | undefined): boolean;
    setDefaultEncoding(encoding: BufferEncoding): any;
    end(cb?: (() => void) | undefined): void;
    end(chunk: any, cb?: (() => void) | undefined): void;
    end(chunk: any, encoding?: BufferEncoding | undefined, cb?: (() => void) | undefined): void;
    cork(): void;
    uncork(): void;
    readonly readableAborted: boolean;
    readable: boolean;
    readonly readableDidRead: boolean;
    readonly readableEncoding: BufferEncoding | null;
    readonly readableEnded: boolean;
    readonly readableFlowing: boolean | null;
    readonly readableHighWaterMark: number;
    readonly readableLength: number;
    readonly readableObjectMode: boolean;
    destroyed: boolean;
    _construct?(callback: (error?: Error | null | undefined) => void): void;
    read(size?: number | undefined): any;
    setEncoding(encoding: BufferEncoding): any;
    pause(): any;
    resume(): any;
    isPaused(): boolean;
    unpipe(destination?: NodeJS.WritableStream | undefined): any;
    unshift(chunk: any, encoding?: BufferEncoding | undefined): void;
    wrap(stream: NodeJS.ReadableStream): any;
    push(chunk: any, encoding?: BufferEncoding | undefined): boolean;
    destroy(error?: Error | undefined): void;
    addListener(event: "close", listener: () => void): any;
    addListener(event: "data", listener: (chunk: any) => void): any;
    addListener(event: "end", listener: () => void): any;
    addListener(event: "error", listener: (err: Error) => void): any;
    addListener(event: "pause", listener: () => void): any;
    addListener(event: "readable", listener: () => void): any;
    addListener(event: "resume", listener: () => void): any;
    addListener(event: string | symbol, listener: (...args: any[]) => void): any;
    emit(event: "close"): boolean;
    emit(event: "data", chunk: any): boolean;
    emit(event: "end"): boolean;
    emit(event: "error", err: Error): boolean;
    emit(event: "pause"): boolean;
    emit(event: "readable"): boolean;
    emit(event: "resume"): boolean;
    emit(event: string | symbol, ...args: any[]): boolean;
    on(event: "close", listener: () => void): any;
    on(event: "data", listener: (chunk: any) => void): any;
    on(event: "end", listener: () => void): any;
    on(event: "error", listener: (err: Error) => void): any;
    on(event: "pause", listener: () => void): any;
    on(event: "readable", listener: () => void): any;
    on(event: "resume", listener: () => void): any;
    on(event: string | symbol, listener: (...args: any[]) => void): any;
    once(event: "close", listener: () => void): any;
    once(event: "data", listener: (chunk: any) => void): any;
    once(event: "end", listener: () => void): any;
    once(event: "error", listener: (err: Error) => void): any;
    once(event: "pause", listener: () => void): any;
    once(event: "readable", listener: () => void): any;
    once(event: "resume", listener: () => void): any;
    once(event: string | symbol, listener: (...args: any[]) => void): any;
    prependListener(event: "close", listener: () => void): any;
    prependListener(event: "data", listener: (chunk: any) => void): any;
    prependListener(event: "end", listener: () => void): any;
    prependListener(event: "error", listener: (err: Error) => void): any;
    prependListener(event: "pause", listener: () => void): any;
    prependListener(event: "readable", listener: () => void): any;
    prependListener(event: "resume", listener: () => void): any;
    prependListener(event: string | symbol, listener: (...args: any[]) => void): any;
    prependOnceListener(event: "close", listener: () => void): any;
    prependOnceListener(event: "data", listener: (chunk: any) => void): any;
    prependOnceListener(event: "end", listener: () => void): any;
    prependOnceListener(event: "error", listener: (err: Error) => void): any;
    prependOnceListener(event: "pause", listener: () => void): any;
    prependOnceListener(event: "readable", listener: () => void): any;
    prependOnceListener(event: "resume", listener: () => void): any;
    prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): any;
    removeListener(event: "close", listener: () => void): any;
    removeListener(event: "data", listener: (chunk: any) => void): any;
    removeListener(event: "end", listener: () => void): any;
    removeListener(event: "error", listener: (err: Error) => void): any;
    removeListener(event: "pause", listener: () => void): any;
    removeListener(event: "readable", listener: () => void): any;
    removeListener(event: "resume", listener: () => void): any;
    removeListener(event: string | symbol, listener: (...args: any[]) => void): any;
    [Symbol.asyncIterator](): AsyncIterableIterator<any>;
    pipe<T extends NodeJS.WritableStream>(destination: T, options?: {
        end?: boolean | undefined;
    } | undefined): T;
    off(eventName: string | symbol, listener: (...args: any[]) => void): any;
    removeAllListeners(event?: string | symbol | undefined): any;
    setMaxListeners(n: number): any;
    getMaxListeners(): number;
    listeners(eventName: string | symbol): Function[];
    rawListeners(eventName: string | symbol): Function[];
    listenerCount(eventName: string | symbol): number;
    eventNames(): (string | symbol)[];
};
declare type EncryptFrameInput = {
    pendingFrame: AccumulatingFrame;
    messageHeader: MessageHeader;
    getCipher: GetCipher;
    isFinalFrame: boolean;
    suite: NodeAlgorithmSuite;
};
export declare function getEncryptFrame(input: EncryptFrameInput): EncryptFrame;
export {};
//# sourceMappingURL=framed_encrypt_stream.d.ts.map